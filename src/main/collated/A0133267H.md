# A0133267H
###### Clear.java
``` java
package main;

import java.util.*;

public class Clear extends Command{

	private ArrayList<Task> taskCleared ;
	
	public Clear(){
		super(CommandType.CLEAR);
	}
	public Clear(ArrayList<Task> taskCleared){
		super(CommandType.CLEAR);
		this.setTaskCleared(taskCleared);
	}
	public ArrayList<Task> getTaskCleared() {
		return taskCleared;
	}
	public void setTaskCleared(ArrayList<Task> taskCleared) {
		this.taskCleared = taskCleared;
	}
	
	
}
```
###### Command.java
``` java
package main;

public class Command {
	//To be used by parser and logic
	public static enum CommandType{
		ADD_DEADLINE("deadline"), ADD_FLOATING("floating"),ADD_EVENT("event"),
		UPDATE("update"), DELETE("delete"), CLEAR("clear"), EXIT("exit"), 
		DISPLAY("display"), SEARCH("search"),UNDO("undo"),REDO("redo"), DONE("done"),
		SAVE("save"),
		UNKNOWN("");

		private String strCommand;

		private CommandType(String strCommand){
			this.strCommand = strCommand;
		}


		public String toString(){
			return strCommand;
		}

	}
		
	
	
	private CommandType commandType;
	private Task task;
	
	/**
	 * Description Superclass method to set the description of the Task.
	 * @param description
	 */
	public Command(Command.CommandType commandType){
		this.commandType = commandType;
		task = null;
	}

	public Task getTask(){
		return task;
	}


	public void setTask(Task task){
		this.task = task;
	}

	/**
	 * Description Superclass method to obtain the description of any of the task objects.
	 * @return strDescription
	 */
	public Command.CommandType getCommandType(){
		return commandType;
	}
}
```
###### DateClass.java
``` java
package main;

import java.text.ParseException;

/***
 *
 * @author Razali
 *
 *  If the date is 24/09/2015
 *  intDay = 24, intMonth = 9, intYear = 2015
 *  strDay = "Thursday", strMonth = "September", strYear = "2015"
 *
 *  Dependencies: DateHandler
 */

public class DateClass implements Comparable<DateClass> {

	// added by Teddy
	private int[] numOfDays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // number of days in non-leap year

	private int intDay;
	private int intMonth;
	private int intYear;

	private String strDay;
	private String strMonth;
	private String strYear;


	public DateClass(int day, int month) throws NoSuchFieldException, ParseException{
		this(day, month, DateHandler.getIntYearNow());
	}

	public DateClass(int day, int month, int year) throws NoSuchFieldException, ParseException{
		intDay = day;
		intMonth = month;
		intYear = year;

		strDay = DateHandler.getStringDay(day, month, year);
		strMonth = DateHandler.getStringMonth(month);
		strYear = DateHandler.getStringYear(year);

	}

	public DateClass(String day, String month, String year) throws NoSuchFieldException, ParseException{

		this(DateHandler.getDate(Integer.valueOf(day), DateHandler.getIntMonth(month), DateHandler.getIntYear(year)));
	}


	public DateClass(String strFullDate) throws NoSuchFieldException, ParseException{
		String[] ddmmyy = strFullDate.split("/");

		intDay = Integer.valueOf(ddmmyy[0]);
		intMonth = Integer.valueOf(ddmmyy[1]);
		intYear = Integer.valueOf(ddmmyy[2]);

		strDay = DateHandler.getStringDay(intDay, intMonth, intYear);
		strMonth = DateHandler.getStringMonth(intMonth);
		strYear = DateHandler.getStringYear(intYear);
	}

	public int getIntDay() {
		return intDay;
	}

	public int getIntMonth() {
		return intMonth;
	}

	public int getIntYear() {
		return intYear;
	}

	public String getStrDay() {
		return strDay;
	}

	public String getStrMonth() {
		return strMonth;
	}

	public String getStrYear() {
		return strYear;
	}

	@Override
	public String toString(){
		return intDay + "/" + intMonth + "/" + intYear;
	}

```
###### DateHandler.java
``` java
package main;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;


/**
 *
 * @author  Razali
 */
public  class DateHandler {


	public static final int NOT_FOUND = -1;


	public static enum Days{
		SUNDAY("Sun", 1), MONDAY("Mon", 2), TUESDAY("Tue", 3), WEDNESDAY("Wed", 4),
		THURSDAY("Thu", 5), FRIDAY("Fri", 6),
		SATURDAY("Sat", 7);

		private int intDayOfWeek;
		private String strDay;

		private Days(String strDay, int intDayOfWeek){
			this.intDayOfWeek = intDayOfWeek;
			this.strDay = strDay;
		}

		/**
		 * @return The integer representation (1-7) of days
		 */
		public int getIntDayOfWeek(){
			return intDayOfWeek;
		}

		/**
		 *
		 * @param strDay String representation of a day. "Monday" to "Sunday"
		 * @return The integer representation (1-7) of days
		 * @throws NoSuchFieldException if strDay does not match
		 */
		public static int getIntDayOfWeek(String strDay) throws NoSuchFieldException{
			for(Days day : Days.values()){
				if(day.getStringDay().equals(strDay)){
					return day.getIntDayOfWeek();
				}
			}

			throw new NoSuchFieldException();
		}

		/**
		 *
		 * @return String representation of enum ranging from "Monday" to "Sunday"
		 */
		public String getStringDay(){
			return strDay;
		}

		/**
		 *
		 * @param intDayOfWeek Integer ranging from (1-7) where 1 represents "Sunday" and 7 represents "Saturday"
		 * @return String representation of enum ranging from "Monday" to "Sunday"
		 * @throws NoSuchFieldException if intDayofWeek is not within (1-7)
		 */
		public static String getStringDay(int intDayOfWeek) throws NoSuchFieldException{

			for(Days day : Days.values()){

				if(day.getIntDayOfWeek() == intDayOfWeek){
					return day.getStringDay();
				}
			}

			throw new NoSuchFieldException();
		}


	}

	/*** HANDLING OF DAYS ***/

	/**
	 * Gets today's date and returns the day of the month in numerical form
	 * Eg: 20/12/2015 returns 20
	 * @return The current day of the month in numerical form
	 */
	public static int getIntDayNow(){
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd");
		String currentDate = simpleDateFormat.format(new Date());
		int intDayNow = Integer.parseInt(currentDate);
		return intDayNow;
	}

	/**
	 * Gets today's date and returns the day of the week in String form
	 * Eg: 20/09/2015 returns "Sunday"
	 * @return The current day of the week in String form
	 */
	public static String getStringDayNow() throws NoSuchFieldException, ParseException{
		int intDayNow = getIntDayNow();
		int intMonthNow = getIntMonthNow();
		int intYearNow = getIntYearNow();
		String strDayNow = getStringDay(intDayNow, intMonthNow, intYearNow);
		return strDayNow;
	}

	/**
	 * Gets the current day given a date.
	 * @param intDayOfMonth The calendar days usually from 1-30
	 * @param strMonth The calendar months. Eg January/March
	 * @param intYear The calendar year. Eg 2015
	 * @return The day of the date. Eg "Monday" or "Tuesday"
	 * @throws ParseException Occurs when a date with "dd/MM/yyyy" cannot be formed
	 * @throws NoSuchFieldException Occurs when the day supplied could not
	 *         be found in the enum Days
	 */
	public static String getStringDay(int intDayOfMonth, String strMonth, int intYear) throws ParseException, NoSuchFieldException {

		return getStringDay(intDayOfMonth, getIntMonth(strMonth), intYear);
	}

	/**
	 *
	 * @param intDayOfMonth The calendar days usually from 1-30
	 * @param strMonth The calendar months. Eg January/March
	 * @param strYear The calendar year. Eg "2015"
	 * @return The day of the date. Eg "Monday" or "Tuesday"
	 * @throws ParseException Occurs when a date with "dd/MM/yyyy" cannot be formed
	 * @throws NoSuchFieldException Occurs when the day supplied could not
	 *         be found in the enum Days
	 */
	public static String getStringDay(int intDayOfMonth, String strMonth, String strYear) throws ParseException, NoSuchFieldException {

		return getStringDay(intDayOfMonth, getIntMonth(strMonth), getIntYear(strYear));
	}

	/**
	 *
	 * @param intintDayOfMonth The calendar days usually from 1-30DayOfMonth
	 * @param intMonth The calendar months. Eg 1 represents January
	 * @param strYear The calendar year. Eg "2015"
	 * @return The day of the date. Eg "Monday" or "Tuesday"
	 * @throws ParseException Occurs when a date with "dd/MM/yyyy" cannot be formed
	 * @throws NoSuchFieldException Occurs when the day supplied could not
	 *         be found in the enum Days
	 */
	public static String getStringDay(int intDayOfMonth, int intMonth, String strYear) throws ParseException, NoSuchFieldException {

		return getStringDay(intDayOfMonth, intMonth, getIntYear(strYear));
	}

	/**
	 *
	 * @param intDayOfMonth The calendar days usually from 1-30
	 * @param intMonth The calendar months. Eg 1 represents January
	 * @param intYear The calendar year. Eg 2015
	 * @return The day of the date. Eg "Monday" or "Tuesday"
	 * @throws ParseException Occurs when a date with "dd/MM/yyyy" cannot be formed
	 * @throws NoSuchFieldException Occurs when the day supplied could not
	 *         be found in the enum Days
	 */
	public static String getStringDay(int intDayOfMonth, int intMonth, int intYear) throws ParseException, NoSuchFieldException {

		Calendar calendar = Calendar.getInstance();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/MM/yyyy");

		Date date = simpleDateFormat.parse(intDayOfMonth + "/" + intMonth + "/" + intYear);
		calendar.setTime(date);

		int intDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
		String strDay = Days.getStringDay(intDayOfWeek);

		return strDay;
	}


	/*** HANDLING OF MONTHS ***/

	/**
	 * Gets the current month given a date.
	 * @return The current month in numerical form. (1-12)
	 */
	public static int getIntMonthNow(){
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM");
		String currentDate = simpleDateFormat.format(new Date());
		int intMonthNow = Integer.parseInt(currentDate);
		return intMonthNow;
	}

	/**
	 * Gets the current month given a date
	 * @return The current month in string form. (January-December)
	 */
	public static String getStringMonthNow(){
		int intMonthNow = getIntMonthNow();
		String strMonthNow = getStringMonth(intMonthNow);
		return strMonthNow;
	}

	/**
	 * Converts a month in string form to numerical form
	 * @param strMonth "January" to "December"
	 * @return Month in numerical form (1-12)
	 */
	public static int getIntMonth(String strMonth) {
		strMonth = strMonth.toUpperCase();
		return java.time.Month.valueOf(strMonth).getValue();
	}

	/**
	 * Converts a month in numerical form to string form
	 * @param intMonth Month in numberical form (1-12)
	 * @return Month in string form ("January" to "December")
	 */
	public static String getStringMonth(int intMonth) {
		return java.time.Month.of(intMonth).toString();
	}

	/*** HANDLING OF YEARS ***/

	/**
	 * Gets the current year
	 * @return Integer representation of the year. Eg 2015
	 */
	public static int getIntYearNow(){
		String strYearNow = getStringYearNow();
		int intYearNow = getIntYear(strYearNow);
		return intYearNow;
	}

	/**
	 * Gets the current year
	 * @return Integer representation of the year. Eg "2015"
	 */
	public static String getStringYearNow(){
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy");
		String strYearNow = simpleDateFormat.format(new Date());

		return strYearNow;
	}

	/**
	 * Converts the year to an Integer
	 * @param String representation of year
	 * @return Integer representation of the year. Eg "2015" to 2015
	 */
	public static int getIntYear(String strYear) {
		return Integer.valueOf(strYear);
	}

	/**
	 * Converts the year to a String
	 * @param intYear Integer representation of year
	 * @return String representation of the year. Eg 2015 to "2015"
	 */
	public static String getStringYear(int intYear) {
		return intYear + "";
	}


	/*** HANDLING OF DATES ***/

	/**
	 * Gets the current full date
	 * @return Date in "dd/MM/yyyy" form
	 */
	public static String getDateNow(){

		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String currentDate = simpleDateFormat.format(new Date());

		return currentDate;

	}

	/**
	 * Gets the full date
	 * @param strDay Numerical Day from ("1" to "31?");
	 * @param strMonth Numerical month from ("1" to "12");
	 * @param strYear Numerical Year Eg "2015"
	 * @return Date in "dd/MM/yyyy" form
	 */
	public static String getDate(String strDay, String strMonth, String strYear) {
		return strDay + "/" + strMonth + "/" + strYear;
	}

	/**
	 *  Gets the full date
	 * @param intDayOfMonth Numerical Day from (1 to 31);
	 * @param intMonth Numerical month from (1 to 12);
	 * @param intYear Numerical Year Eg 2015
	 * @return Date in "dd/MM/yyyy" form
	  * @throws ParseException Occurs when a date with "dd/MM/yyyy" cannot be formed
	 * @throws NoSuchFieldException Occurs when the day supplied could not
	 *         be found in the enum Days
	 */
	public static String getDate(int intDayOfMonth, int intMonth, int intYear) throws ParseException, NoSuchFieldException {

		return getDate(intDayOfMonth + "", intMonth + "", intYear + "");
	}


	/**
	 * Try to parse a string to an date format of dd/MM/YYYY. If year is not
	 * specified, the current year is used.
	 * @param strDate dd/MM or dd/MM/YYYY string format of a date
	 * @return Null if match not found, else returns dd/MM/YYYY as a string
	 */
	public static String tryParse(String strDate){

		String[] splitDate = strDate.split("/");
		int intLengthOfSplit = splitDate.length;
		if(intLengthOfSplit == 0 || intLengthOfSplit == 1){
			return null;
		} 	else if(intLengthOfSplit == 2){//probably only has day and month, missing year
			String strYear = getStringYearNow();
			return strDate + "/" + strYear;
		}	else if(intLengthOfSplit == 3){
			return strDate;
		}



		return null;
	}

	/**
	 * Determines if a month is within range
	 * @param intMonth Integer representation of a month. (1-12)
	 * @return true if it is within range, false otherwise
	 */
	public static boolean isMonthWithinRange(int intMonth){
		return intMonth >= 1 && intMonth <= 12;
	}

	public static boolean isBeforeToday(DateClass date){
		String strDateNow = getDateNow();
		DateClass dateNow;
		try {
			dateNow = new DateClass(strDateNow);
		} catch (NoSuchFieldException e) {
			return false;
		} catch (ParseException e) {
			return false;
		}
		
		return date.compareTo(dateNow) < 0 ? true : false;
	}
	
	public static boolean isToday(DateClass date){
		String strDateNow = getDateNow();
		DateClass dateNow;
		try {
			dateNow = new DateClass(strDateNow);
		} catch (NoSuchFieldException e) {
			return false;
		} catch (ParseException e) {
			return false;
		}
		
		return date.compareTo(dateNow) == 0 ? true : false;
	}
}
```
###### Deadline.java
``` java
package main;

public class Deadline extends Task {

	private DateClass endDate;
	private TimeClass endTime;

	/**
	 * Description Constructor : Creates a deadline task, which is a subclass of the Deadline abstract class.
	 * @param description
	 * @param endDate
	 * @param endTime
	 */
	public Deadline(String description, DateClass endDate, TimeClass endTime){
		super(description);
		this.endDate = endDate;
		this.endTime = endTime;

	}

	/**
	 * Description Gets the endDate of the deadline
	 * @return endDate
	 */
	public DateClass getEndDate(){
		return endDate;
	}

	/**
	 * Description Gets the endTime of the deadline
	 * @return endTime
	 */
	public TimeClass getEndTime(){
		return endTime;
	}

	public void setEndTime(TimeClass endTime) {
		this.endTime = endTime;
	}

	public void setEndDate(DateClass endDate) {
		this.endDate = endDate;
	}
	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString(){
		String output = "";
		output = this.getDescription() + " " + this.getEndDate().toString() + " " + this.getEndTime().toString();
		return output;
	}

```
###### Delete.java
``` java
package main;

import java.util.*;

public class Delete extends Command{

	private String strDeleteString;
	private Set<Integer> taskIDs;
	private ArrayList<Task> taskDeleted;
	
	public Delete(String input){
		super(CommandType.DELETE);
		strDeleteString = input;
		taskDeleted = null;
		taskIDs = null;
	}
	
	public Delete(Set<Integer> taskIDs){
		super(CommandType.DELETE);
		this.taskIDs = taskIDs;
		strDeleteString = null;
		taskDeleted = null;
	}
	
	public String getDeleteString(){
		return strDeleteString;
	}
	
	public void setTaskDeleted(ArrayList<Task> taskDeleted){
		this.taskDeleted = taskDeleted;
	}
	
	public ArrayList<Task> getTaskDeleted(){
		return taskDeleted;
	}
	
	public Set<Integer> getTaskIDs(){
		return taskIDs;
	}
	
	public boolean hasTaskIDs(){
		return taskIDs != null ;
	}
	
	public boolean hasDeleteString(){
		return strDeleteString != null;
	}
	
}
```
###### Display.java
``` java
package main;

public class Display extends Command{

	String strDisplayString;
	
	public Display(String strDisplayString){
		super(CommandType.DISPLAY);
		
		if(strDisplayString == null || strDisplayString.equals("")){
			this.strDisplayString = null;
		}else{
			this.strDisplayString = strDisplayString;
		}
	}
	
	public String getDisplayString(){
		return strDisplayString;
	}
}
```
###### Done.java
``` java
package main;

import java.util.*;

public class Done extends Command{
	
	Set<Integer> taskIDs;
	ArrayList<Task> tasksSetDone;
	
	public Done(Set<Integer> IDs){
		super(CommandType.DONE);
		taskIDs = IDs;
	}
	
	public Done(Set<Integer> IDs, ArrayList<Task> tasksSetDone){
		super(CommandType.DONE);
		taskIDs = IDs;
		this.tasksSetDone = tasksSetDone;
	}
	
	public Set<Integer> getTaskIDs(){
		return taskIDs;
	}
	
	public ArrayList<Task> getTasksSetDone(){
		return tasksSetDone;
	}
	
	
}
```
###### Event.java
``` java
package main;

public class Event extends Task {


	private DateClass startDate;
	private DateClass endDate;
	private TimeClass startTime;
	private TimeClass endTime;


	/**
	 * Description Constructor : Creates a event task, which is a subclass of the Command abstract class.
	 * @param strDescription
	 * @param startDate
	 * @param startTime
	 * @param endDate
	 * @param endTime
	 */
	public Event(String strDescription, DateClass startDate, TimeClass startTime, DateClass  endDate, TimeClass endTime){

		super(strDescription);
		this.startDate = startDate;
		this.endDate = endDate;
		this.startTime = startTime;
		this.endTime = endTime;

	}

	/**
	 * Description Gets the startDate of the event
	 * @return startDate
	 */
	public DateClass getStartDate() {
		return startDate;
	}

	public void setStartDate(DateClass startDate){
		this.startDate = startDate;
	}
	/**
	 * Description Gets the endDate of the event
	 * @return
	 */
	public DateClass getEndDate() {
		return endDate;
	}

	public void setEndDate(DateClass endDate) {
		this.endDate = endDate;
	}

	/**
	 * Description Gets the startTime of the event
	 * @return
	 */
	public TimeClass getStartTime() {
		return startTime;
	}

	public void setStartTime(TimeClass startTime) {
		this.startTime = startTime;
	}

	/**
	 * Description Gets the endTime of the event
	 * @return
	 */
	public TimeClass getEndTime() {
		return endTime;
	}

	public void setEndTime(TimeClass endTime) {
		this.endTime = endTime;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString(){
		String output = "";
		output = this.getDescription() + " " + this.getStartDate().toString() + " " + this.getStartTime().toString()+ " "  + this.getEndDate().toString() + " " + this.getEndTime().toString();
		return output;
	}

```
###### Exit.java
``` java
package main;

public class Exit extends Command{

	public Exit(){
		super(CommandType.EXIT);
	}
}
```
###### Floating.java
``` java
package main;

public class Floating extends Task{

	/**Description Constructor : Creates a floating task, which is a subclass of the Command abstract class.
	 * @param strDescription
	 */
	 
	
	public Floating (String strDescription){
		super(strDescription); 
	}
	
	
	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString(){
		String output = this.getDescription()+" ";
		return output;

	}


	@Override
	public int compareTo(Task o) {
		// TODO Auto-generated method stub
		return 0;
	}
}
```
###### Parser.java
``` java
package main;

import java.text.ParseException;
import java.util.*;

import main.Command.CommandType;

/***
 * 
 * @author Razali
 *
 */

public class Parser {

	private ParserUtils parserUtils;

	public Parser() {
		parserUtils = new ParserUtils();
	}

	/* Command verifying methods */

	/**
	 * 
	 * @param strCommand
	 *            A command to parse to an task
	 * @return TaskPair o
	 * @throws ParseException
	 * @throws NoSuchFieldException
	 */
	private boolean isAnAddCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("add")) {
			return true;
		}
		return false;
	}

	private boolean isAClearCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("clear")) {
			return true;
		}
		return false;

	}

	private boolean isASaveCommand(String strCommand) {
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("save")) {
			return true;
		}
		return false;
	}

	private boolean isAnEventCommand(String strCommand) {

		// else find for "at" and make sure it comes before "by" which is for
		// evenet

		String[] splitWords = strCommand.split(" ");

		for (int i = splitWords.length - 1; i >= 0; i--) {
			if (splitWords[i].equals("by") || splitWords[i].equals("in")
					|| splitWords[i].equals("due")) {
				return false;
			} else if (splitWords[i].equals("at")) {
				return true;
			}
		}

		// If strCommand has "from" and "to", its an event!
		if (parserUtils.containsWord("from", strCommand)
				&& parserUtils.containsWord("to", strCommand)) {
			return true;
		}
		return false;
	}

	private boolean isADeadlineCommand(String strCommand) {
		// If strCommand has "by", its a deadline!
		String[] splitWords = strCommand.split(" ");

		for (int i = splitWords.length - 1; i >= 0; i--) {
			if (splitWords[i].equals("by") || splitWords[i].equals("in")
					|| splitWords[i].equals("due")) {
				return true;
			}
		}

		return false;
	}

	private String preprocessNLP(String strNLP) {
		strNLP = strNLP.replace("tmr", "tomorrow");
		strNLP = strNLP.replace("nxt", "next");
		strNLP = strNLP.replace("wk", "week");

		return strNLP;
	}

	private boolean isAnUpdateCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("update")) {
			return true;
		}
		return false;
	}

	private boolean isAnExitCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("exit")) {
			return true;
		}
		return false;

	}

	private boolean isASearchCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("search")) {
			return true;
		}
		return false;
	}

	private boolean isAnUndoCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("undo")) {
			return true;
		}
		return false;
	}

	private boolean isARedoCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("redo")) {
			return true;
		}
		return false;
	}

	private boolean isADisplayCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("display") || strFirstWord.equals("show")) {
			return true;
		}
		return false;
	}

	private String replaceLast(String string, String substring,
			String replacement) {
		int index = string.lastIndexOf(substring);
		if (index == -1)
			return string;
		return string.substring(0, index) + replacement
				+ string.substring(index + substring.length());
	}

	private boolean isADeleteCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("delete") || strFirstWord.equals("remove")) {
			return true;
		}
		return false;
	}

	private boolean isADoneCommand(String strCommand) {
		// If the first word is update
		String strFirstWord = parserUtils.getWord(0, strCommand);
		if (strFirstWord.equals("done")) {
			return true;
		}
		return false;
	}

	/* Parsing Methods */

	private Update parseUpdateCommand(String strCommand) {

		strCommand = parserUtils.removeNWords(1, strCommand);

		UpdateTask updateTask = new UpdateTask();

		/*
		 * get task id
		 */
		int taskID;
		try {
			taskID = Integer.valueOf(parserUtils.getWord(0, strCommand));
		} catch (NumberFormatException n) {
			return null;
		}

		updateTask.setTaskID(taskID);

		// remove taskID
		strCommand = parserUtils.removeNWords(1, strCommand);

		while (!strCommand.equals("")) {
			// Get delimiter
			String delimiter = parserUtils.getWord(0, strCommand);

			if (parserUtils.isDelimeter(delimiter) == false) {
				break;
			}

			strCommand = parserUtils.removeNWords(1, strCommand);

			switch (delimiter) {
			case "-d":
				String strDescription = parserUtils
						.removeDelimiters(parserUtils
								.getDescription(strCommand));
				updateTask.setDescription(strDescription.equals("") ? null
						: strDescription);

				strCommand = parserUtils.removeNWords(
						strDescription.split(" ").length, strCommand);
				break;
			case "-e":
				String strEndDateTime = parserUtils.getUpdateEndDateTimeString(
						strCommand).trim();
				String strEndDateTimeCopy = new String(strEndDateTime);
				DateClass endDate = parseDate(strEndDateTimeCopy);
				strEndDateTimeCopy = parserUtils.removeDate(strEndDateTimeCopy);
				TimeClass endTime = parseTime(strEndDateTimeCopy);

				if (endDate == null && endTime == null) {
					return null;
				}
				
				if(endDate != null && DateHandler.isBeforeToday(endDate)){
					return null;
				}
				
				if((endDate!= null && endTime != null) && DateHandler.isToday(endDate) && TimeHandler.isBeforeNow(endTime)){
					return null;
				}
				
				strCommand = strCommand.replace(strEndDateTime, "").trim();

				updateTask.setEndDate(endDate);
				updateTask.setEndTime(endTime);

				break;
			case "-s":
				String strStartDateTime = parserUtils.getUpdateStartDateTimeString(strCommand).trim();
				String strStartDateTimeCopy = new String(strStartDateTime);
				DateClass startDate = parseDate(strStartDateTimeCopy);
				strStartDateTimeCopy = parserUtils.removeDate(strStartDateTimeCopy);
				TimeClass startTime = parseTime(strStartDateTimeCopy);
				if (startDate == null && startTime == null) {
					return null;
				}
				
				if(startDate != null && DateHandler.isBeforeToday(startDate)){
					return null;
				}
				
				if((startDate!= null && startTime != null) && DateHandler.isToday(startDate) && TimeHandler.isBeforeNow(startTime)){
					return null;
				}
				
				
				strCommand = strCommand.replace(strStartDateTime, "").trim();

				updateTask.setStartDate(startDate);
				updateTask.setStartTime(startTime);

				break;

			}
		}

		// Incorrect update format?? By this point should have parsed everything
		if (strCommand.equals("") == false) {

			// Check if it is a task id
			return null;
		}

		// parsed nothing!
		if (strCommand.equals("") && updateTask.getDescription() == null
				&& updateTask.getEndDate() == null
				&& updateTask.getStartDate() == null && updateTask.getEndTime() == null && updateTask.getStartTime() == null) {
			return null;
		}

		return new Update(updateTask);
	}

	private Command parseAddCommand(String strCommand) {

		String strDescription;
		String strStartDateAndStartTime = null;
		TimeClass startTime = null, endTime = null;
		DateClass startDate = null, endDate = null;
		Command command;

		// 1. Remove "add" from command
		strCommand = parserUtils.removeNWords(1, strCommand);

		// Add command can be for Deadline, Floating or Event,

		if (isAnEventCommand(strCommand) == true) {
			/*
			 * Required Event Syntax for successful parsing: Description from
			 * startdate, starttime to enddate endtime
			 */

			// <------------------Handling End Date and Time---------->
			String strEndDateAndEndTime = null;
			if (strCommand.contains("from") && strCommand.contains("to")) {
				strEndDateAndEndTime = strCommand.substring(strCommand.lastIndexOf("to"));

				strEndDateAndEndTime = preprocessNLP(strEndDateAndEndTime);

				endDate = parserUtils.getDate(strEndDateAndEndTime);
				endTime = parserUtils.getTime(strEndDateAndEndTime);

				if (endDate == null && endTime == null) {
					// use natural language to try get DateClass
					PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strEndDateAndEndTime);
					endDate = prettyTime.getDate();
					endTime = prettyTime.getTime();
				} else if (endDate != null && endTime == null) {
					String strWithoutDate = parserUtils.removeDate(strEndDateAndEndTime);
					// use natural language to try get DateClass
					PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strWithoutDate);
					endTime = prettyTime.getTime();

				} else if (endDate == null && endTime != null) {
					String strWithoutTime = parserUtils.removeTime(strEndDateAndEndTime);
					// use natural language to try get DateClass
					PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strWithoutTime);
					endDate = prettyTime.getDate();
				}
				strCommand = replaceLast(strCommand, strEndDateAndEndTime, "").trim();
				strStartDateAndStartTime = strCommand.substring(strCommand.lastIndexOf("from"));
			} else if (strCommand.contains("at")) {
				strStartDateAndStartTime = strCommand.substring(strCommand.lastIndexOf("at"));

			}

			// <-----------------Handling Start Date and Time--------->

			strStartDateAndStartTime = preprocessNLP(strStartDateAndStartTime);

			startDate = parserUtils.getDate(strStartDateAndStartTime);
			startTime = parserUtils.getTime(strStartDateAndStartTime);

			if (startDate == null && startTime == null) {
				// use natural language to try get DateClass
				PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strStartDateAndStartTime);
				startDate = prettyTime.getDate();
				startTime = prettyTime.getTime();
			} else if (startDate != null && startTime == null) {
				String strWithoutDate = parserUtils.removeDate(strStartDateAndStartTime);
				// use natural language to try get DateClass
				PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strWithoutDate);
				startTime = prettyTime.getTime();

			} else if (startDate == null && startTime != null) {
				String strWithoutTime = parserUtils.removeTime(strCommand);
				// use natural language to try get DateClass
				PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strWithoutTime);
				startDate = prettyTime.getDate();
			}
			strCommand = strCommand.replace(strStartDateAndStartTime, "").trim();

			if (endDate == null) {
				endDate = startDate;
			}
			if (endTime == null) {
				endTime = new TimeClass("2359");
			}
			if (startTime == null) {
				startTime = new TimeClass("0000");
			}
			strDescription = strCommand;

			// NO description found!
			if (strDescription.replaceAll(" ", "") == "")
				return null;

			// No startdatetime or enddatetime
			if (startDate == null && startTime == null || endDate == null && endTime == null)
				return null;

			if (startDate == null) {
				try {
					startDate = new DateClass(DateHandler.getDateNow());
				} catch (NoSuchFieldException | ParseException e) {
					return null;
				}
			}

			if (endDate == null) {
				try {
					endDate = new DateClass(DateHandler.getDateNow());
				} catch (NoSuchFieldException | ParseException e) {
					// TODO Auto-generated catch block
					return null;
				}
			}
			
			if(endTime.compareTo(new TimeClass(TimeHandler.getHourNow(), TimeHandler.getMinuteNow())) == 0){
				endTime = new TimeClass("2359");
			}
			
			//boundary check

			if(endDate.compareTo(startDate) < 0){
				return null;
			} else if(endDate.compareTo(startDate) == 0 && endTime.compareTo(startTime) <=0){
				return null;
			}
			
			if(DateHandler.isBeforeToday(endDate) || DateHandler.isBeforeToday(startDate)){
				return null;
			}
			
			if(DateHandler.isToday(startDate) && TimeHandler.isBeforeNow(startTime)){
				return null;
			}
			
			if(DateHandler.isToday(endDate) && TimeHandler.isBeforeNow(endTime)){
				return null;
			}
			
			
			
			
			command = new Command(CommandType.ADD_EVENT);
			
			
			command.setTask(new Event(strDescription, startDate, startTime, endDate, endTime));

			return command;
		} else if (isADeadlineCommand(strCommand) == true) {
			/*
			 * Required Event Syntax for successful parsing: Description by
			 * enddate endtime
			 */
			// <------------------Handling End Date and Time---------->
			String strEndDateAndEndTime = null;
			String[] splitWords = strCommand.split(" ");

			for (int i = splitWords.length - 1; i >= 0; i--) {
				if (splitWords[i].equals("by")) {
					strEndDateAndEndTime = strCommand.substring(strCommand.lastIndexOf("by"));
					break;
				} else if (splitWords[i].equals("in")) {
					strEndDateAndEndTime = strCommand.substring(strCommand.lastIndexOf("in"));
					break;
				} else if (splitWords[i].equals("due")) {
					strEndDateAndEndTime = strCommand.substring(strCommand.lastIndexOf("due"));
					break;
				}
			}

			// PreProcess
			strEndDateAndEndTime = preprocessNLP(strEndDateAndEndTime);

			endDate = parserUtils.getDate(strEndDateAndEndTime);
			endTime = parserUtils.getTime(strEndDateAndEndTime);

			if (endDate == null && endTime == null) {
				// use natural language to try get DateClass
				PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strEndDateAndEndTime);
				endDate = prettyTime.getDate();
				endTime = prettyTime.getTime();
			} else if (endDate != null && endTime == null) {
				String strWithoutDate = parserUtils.removeDate(strEndDateAndEndTime);
				// use natural language to try get DateClass
				PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strWithoutDate);
				endTime = prettyTime.getTime();

			} else if (endDate == null && endTime != null) {
				String strWithoutTime = parserUtils.removeTime(strEndDateAndEndTime);
				// use natural language to try get DateClass
				PrettyTimeWrapper prettyTime = new PrettyTimeWrapper(strWithoutTime);
				endDate = prettyTime.getDate();
			}
			strCommand = strCommand.replace(strEndDateAndEndTime, "").trim();

			strDescription = strCommand;

			// NO description found!
			if (strDescription.replaceAll(" ", "") == "")
				return null;

			// No enddatetime
			if (endDate == null && endTime == null)
				return null;

			if (endDate == null) {
				try {
					endDate = new DateClass(DateHandler.getDateNow());
				} catch (NoSuchFieldException | ParseException e) {
					// TODO Auto-generated catch block
					return null;
				}
			}

			if (endTime == null) {
				endTime = new TimeClass(TimeHandler.getHourNow() + "", TimeHandler.getMinuteNow() + "");
			}
			///DateHandler.getDateNow()new DateClass()
			
			if(endTime.compareTo(new TimeClass(TimeHandler.getHourNow(), TimeHandler.getMinuteNow())) == 0){
				endTime = new TimeClass("2359");
			}
			
			if(DateHandler.isBeforeToday(endDate)){
				return null;
			}
			
			if(DateHandler.isToday(endDate) && TimeHandler.isBeforeNow(endTime)){
				return null;
			}
			
			command = new Command(CommandType.ADD_DEADLINE);

			command.setTask(new Deadline(strDescription, endDate, endTime));
			return command;
		} else {// Floating task
			/*
			 * Required Event Syntax for successful parsing: Description
			 */
			strDescription = strCommand;
			
			if(strDescription.equals("")){
				return null;
			}
			
			command = new Command(CommandType.ADD_FLOATING);

			command.setTask(new Floating(strDescription));
			return command;
		}

	}

	private Command parseSearchCommand(String strCommand) {
		// remove "search" word
		String strSearchString = parserUtils.removeNWords(1, strCommand);

		String enclosedString = parserUtils
				.getEnclosedDescription(strSearchString);

		if (enclosedString != null) {
			enclosedString = enclosedString.equals("") == true ? null
					: enclosedString;
			strSearchString = strSearchString.substring(
					strSearchString.lastIndexOf("\"") + 1).trim();

			if (strSearchString == "") {
				return new Search(enclosedString);
			}

			// else find for dates
			if (strSearchString.matches("after .+")
					|| strSearchString.matches("before .+")
					|| strSearchString.matches("on .+")) {
				String firstWord = parserUtils.getWord(0, strSearchString);
				strSearchString = parserUtils.removeNWords(1, strSearchString);
				DateClass firstDate = parseDate(strSearchString);

				if (firstDate == null) {
					return null;
				}

				Search search = new Search(enclosedString, firstDate);
				if (firstWord.equals("after")) {
					search.setAfter(true);
				} else if (firstWord.equals("before")) {
					search.setBefore(true);
				} else {
					search.setOn(true);
				}
				return search;
			} else if (strSearchString.matches("from .+ to .+")) {

				int indexOfTo = strSearchString.lastIndexOf("to");
				String strTo = strSearchString.substring(indexOfTo)
						.replace("to", "").trim();

				int indexOfFrom = strSearchString.lastIndexOf("from");
				String strFrom = strSearchString
						.substring(indexOfFrom, indexOfTo).replace("from", "")
						.trim();

				DateClass firstDate, secondDate;
				firstDate = parseDate(strFrom);
				secondDate = parseDate(strTo);

				if (firstDate == null || secondDate == null) {
					return null;
				}

				Search search = new Search(enclosedString, firstDate,
						secondDate);
				search.setBetween(true);
				return search;
			} else {
				return null;
			}

		}

		// find to/after/before/on
		String[] splitWords = strSearchString.split(" ");
		String firstFoundWord = null;

		for (int i = splitWords.length - 1; i >= 0; i--) {
			if (splitWords[i].equals("to") || splitWords[i].equals("after")
					|| splitWords[i].equals("before")
					|| splitWords[i].equals("on")) {
				firstFoundWord = splitWords[i];
				break;
			}
		}

		if (firstFoundWord == null) {
			return new Search(strSearchString);
		} else if (firstFoundWord.equals("to")) {
			int indexOfTo = strSearchString.lastIndexOf("to");
			String strTo = strSearchString.substring(indexOfTo)
					.replace("to", "").trim();

			int indexOfFrom = strSearchString.lastIndexOf("from");
			String strFrom = strSearchString.substring(indexOfFrom, indexOfTo)
					.replace("from", "").trim();

			DateClass firstDate, secondDate;
			firstDate = parseDate(strFrom);
			secondDate = parseDate(strTo);

			if (firstDate == null || secondDate == null) {
				return null;
			}

			strSearchString = strSearchString.substring(0, indexOfFrom).trim();
			strSearchString = strSearchString.equals("")
					|| strSearchString.equals("\"\"") ? null : strSearchString;

			Search search = new Search(strSearchString, firstDate, secondDate);
			search.setBetween(true);
			return search;
		} else {// before//after//on
			String[] strSplit = strSearchString.split(firstFoundWord);
			if (strSplit.length != 2) {
				return null;
			}

			DateClass firstDate = parseDate(strSplit[1].trim());

			if (firstDate == null) {
				return null;
			}

			strSearchString = strSplit[0].trim();
			strSearchString = strSearchString.equals("")
					|| strSearchString.equals("\"\"") ? null : strSearchString;

			Search search = new Search(strSearchString, firstDate);
			if (firstFoundWord.equals("after")) {
				search.setAfter(true);
			} else if (firstFoundWord.equals("before")) {
				search.setBefore(true);
			} else {
				search.setOn(true);
			}
			return search;
		}

	}

	private DateClass parseDate(String text) {
		DateClass firstDate = null;
		String[] splitWords = text.split(" ");

		for (String word : splitWords) {

			try {
				String strFirstDate = DateHandler.tryParse(word);
				firstDate = strFirstDate == null ? null : new DateClass(
						strFirstDate);
			} catch (NoSuchFieldException e) {
				return null;
			} catch (ParseException e) {
				return null;
			}

			if (firstDate != null)
				return firstDate;
		}

		if (firstDate == null) {
			PrettyTimeWrapper ptw = new PrettyTimeWrapper(text);
			firstDate = ptw.getDate();
		}

		return firstDate == null ? null : firstDate;
	}

	private TimeClass parseTime(String text) {
		TimeClass time = null;
		String[] splitWords = text.split(" ");

		for (String word : splitWords) {

			time = TimeHandler.parse(word);

			if (time != null)
				return time;
		}

		if (time == null) {
			PrettyTimeWrapper ptw = new PrettyTimeWrapper(text);
			time = ptw.getTime();
		}

		return time == null ? null : time;
	}

	private Command parseUndoCommand(String strCommand) {
		return new Undo();
	}

	private Command parseRedoCommand(String strCommand) {
		return new Redo();
	}

	private Command parseDisplayCommand(String strCommand) {
		String displayString = parserUtils.removeNWords(1, strCommand);
		return new Display(displayString);
	}

	private Command parseDeleteCommand(String strCommand) {
		strCommand = parserUtils.removeNWords(1, strCommand);

		String enclosedDescription = parserUtils
				.getEnclosedDescription(strCommand);

		// Delete has "xxx" description
		if (enclosedDescription != null) {
			return new Delete(enclosedDescription);
		}

		Set<Integer> taskIDs = parserUtils.getRangeSet(strCommand);

		// Has task ids
		if (taskIDs != null) {
			return new Delete(taskIDs);
		}

		// Else if no task ids and no "xx", treat them as desc
		return new Delete(strCommand);
	}

	private Command parseDoneCommand(String strCommand) {
		strCommand = parserUtils.removeNWords(1, strCommand);

		String[] strSplit = strCommand.split(",");
		Set<Integer> parsedIDs = new TreeSet<Integer>();

		for (String str : strSplit) {
			str = str.replaceAll(" ", ""); // remove all white spaces

			if (str.matches("\\d+-\\d+")) {
				int firstDigit = Integer.valueOf(str.split("-")[0]);
				int secondDigit = Integer.valueOf(str.split("-")[1]);

				// make first smaller than second
				if (firstDigit > secondDigit) {
					firstDigit ^= secondDigit;
					secondDigit = firstDigit;
					firstDigit ^= secondDigit;

				}

				for (int i = firstDigit; i <= secondDigit; i++) {
					parsedIDs.add(i);
				}
			} else if (str.matches("\\d+")) {
				parsedIDs.add(Integer.valueOf(str));
			}
		}

		if (parsedIDs.isEmpty()) {
			return null;
		} else {
			Done doneCommand = new Done(parsedIDs);
			return doneCommand;
		}
	}

	private Command parseSaveCommand(String strCommand) {
		strCommand = parserUtils.removeNWords(1, strCommand);
		return new Save(strCommand);
	}

	private Command parseExitCommand(String strCommand) {
		return new Exit();
	}

	private Command parseClearCommand(String strCommand) {
		return new Clear();
	}

	public Command parse(String strCommand) {

		Command parsedCommand;

		if (strCommand.equals("")) {
			parsedCommand = null;
		} else if (isAnAddCommand(strCommand)) {
			parsedCommand = parseAddCommand(strCommand);
		} else if (isAnUpdateCommand(strCommand)) {
			parsedCommand = parseUpdateCommand(strCommand);
		} else if (isASearchCommand(strCommand)) {
			parsedCommand = parseSearchCommand(strCommand);
		} else if (isAnUndoCommand(strCommand)) {
			parsedCommand = parseUndoCommand(strCommand);
		} else if (isARedoCommand(strCommand)) {
			parsedCommand = parseRedoCommand(strCommand);
		} else if (isADisplayCommand(strCommand)) {
			parsedCommand = parseDisplayCommand(strCommand);
		} else if (isADeleteCommand(strCommand)) {
			parsedCommand = parseDeleteCommand(strCommand);
		} else if (isADoneCommand(strCommand)) {
			parsedCommand = parseDoneCommand(strCommand);
		} else if (isAnExitCommand(strCommand)) {
			parsedCommand = parseExitCommand(strCommand);
		} else if (isAClearCommand(strCommand)) {
			parsedCommand = parseClearCommand(strCommand);
		} else if (isASaveCommand(strCommand)) {
			parsedCommand = parseSaveCommand(strCommand);
		} else {
			parsedCommand = null;
		}

		return parsedCommand == null ? new Command(CommandType.UNKNOWN)
				: parsedCommand;
	}

	public static void main(String[] args) throws NoSuchFieldException,
			ParseException {
		Parser p = new Parser();

		// String command = "update new swimming -d swimming";
		Command t;
		String command;
		command = "update 1 -s 0700";
		t = p.parse(command);

		System.out.println(((Event) t.getTask()).getEndTime().to12HourFormat());

	}

}
```
###### ParserUtils.java
``` java
package main;

import java.text.ParseException;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;

public class ParserUtils {
	
	public String getEnclosedDescription(String text){
		int firstOccurrence, lastOccurrence;
		
		firstOccurrence = text.indexOf('"');
		lastOccurrence = text.lastIndexOf('"');
		
		if(firstOccurrence == -1 || lastOccurrence == -1){
			return null;
		}
		
		String subString = text.substring(firstOccurrence+1, lastOccurrence);
		
		return subString;
	}
	
	public Set<Integer> getRangeSet(String text){
		String[] strSplit = text.split(",");
		Set<Integer> parsedIDs = new TreeSet<Integer>();

		for (String str : strSplit) {
			str = str.replaceAll(" ", ""); // remove all white spaces

			if (str.matches("\\d+-\\d+")) {
				int firstDigit = Integer.valueOf(str.split("-")[0]);
				int secondDigit = Integer.valueOf(str.split("-")[1]);

				// make first smaller than second
				if (firstDigit > secondDigit) {
					firstDigit ^= secondDigit;
					secondDigit = firstDigit;
					firstDigit ^= secondDigit;

				}

				for (int i = firstDigit; i <= secondDigit; i++) {
					parsedIDs.add(i);
				}
			} else if (str.matches("\\d+")) {
				parsedIDs.add(Integer.valueOf(str));
			}
		}
		
		return parsedIDs.size() == 0 ? null : parsedIDs; 
	}

	public boolean containsWord(String word, String text){
		String[] splitWord = text.split(" ");
		
		for(String string : splitWord){
			if(string.equals(word)){
				return true;
			}
		}
		
		return false;
	}
	
	public String getWord(int intIndex, String strText) {
		String[] words = strText.split(" ");

		if (intIndex < 0 || intIndex >= words.length)
			return null;

		return words[intIndex];
	}
	
	public String removeNWords(int numOfWordsToRemove, String strText) {
		int intRemoved = 0;
		String strWord;

		while (intRemoved != numOfWordsToRemove) {
			strWord = getWord(0, strText);
			strText = strText.replaceFirst(strWord, "").trim();

			intRemoved++;
		}

		return strText;
	}
	
	public int getNumberOfWords(String strText) {
		return strText.split(" ").length;
	}
	
	public boolean isDelimeter(String word){
		return word.equals("-e") || word.equals("-s") || word.equals("-d");
	}

	public String removeDelimiters(String strText) {
		strText = strText.replaceAll("-d", "").trim();
		strText = strText.replaceAll("-e", "").trim();
		strText = strText.replaceAll("-s", "").trim();

		return strText;
	}
	
	
	public String getDescription(String strCommand) {
		StringBuilder sb = new StringBuilder();
		int intWordIndex = 0;

		String strNextWord = getWord(intWordIndex, strCommand);

		while (DateHandler.tryParse(strNextWord) == null) {
			sb.append(strNextWord + " ");
			intWordIndex++;
			strNextWord = getWord(intWordIndex, strCommand);
			if (strNextWord == null)
				break;
		}

		String strDescription = sb.toString().trim();

		return strDescription;
	}


	public DateClass getDate(String strCommand) {
		String parsedDate;

		String[] strSplitWords = strCommand.split(" ");

		for (String word : strSplitWords) {
			parsedDate = DateHandler.tryParse(word);
			if (parsedDate != null) {
				try {
					return new DateClass(parsedDate);
				} catch (NoSuchFieldException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}

		return null;
	}
	
	public String getUpdateStartDateTimeString(String strCommand){
		String[] splitWords = strCommand.split(" ");
		StringBuilder sb = new StringBuilder();
		
		for(String word : splitWords){
			if(word.equals("-d") || word.equals("-e"))
				break;
			sb.append(word + " ");
		}
		
		return sb.toString().trim();
	}
	
	public String getUpdateEndDateTimeString(String strCommand){
		String[] splitWords = strCommand.split(" ");
		StringBuilder sb = new StringBuilder();
		
		for(String word : splitWords){
			if(word.equals("-d") || word.equals("-s"))
				break;
			sb.append(word + " ");
		}
		
		return sb.toString().trim();
	}
	public String removeDate(String strCommand) {
		String parsedDate;
		Stack<String> dateBuffer = new Stack<String>();

		String[] strSplitWords = strCommand.split(" ");

		for (String word : strSplitWords) {
			parsedDate = DateHandler.tryParse(word);
			if (parsedDate != null) {
				dateBuffer.push(word);
			}
		}

		
		return dateBuffer.size() != 0 ? strCommand.replace(dateBuffer.pop(), "").trim() : strCommand;
	}

	public TimeClass getTime(String strCommand) {
		String[] strSplitWords = strCommand.split(" ");
		TimeClass time = null;

		for (String word : strSplitWords) {
			if ((time = TimeHandler.parse(word)) != null) {
				return time;
			}
		}

		return time;
	}

	public String removeTime(String strCommand) {
		String[] strSplitWords = strCommand.split(" ");
		TimeClass time = null;
		Stack<String> timeBuffer = new Stack<String>();

		for (String word : strSplitWords) {
			if ((time = TimeHandler.parse(word)) != null) {
				timeBuffer.push(word);
			}
		}

		return strCommand.replace(timeBuffer.pop(), "").trim();
	}

}
```
###### PrettyTimeWrapper.java
``` java
package main;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import org.ocpsoft.prettytime.nlp.parse.DateGroup;


public class PrettyTimeWrapper {
	
	public static final String[][] prettyTimeMonths = {
			{"Jan", "January"},
			{"Feb", "February"},
			{"March", "March"},
			{"Apr", "April"},
			{"May", "May"},
			{"Jun", "June"},
			{"Jul", "July"},
			{"Aug", "August"},
			{"Sep", "September"},
			{"Oct", "October"},
			{"Nov", "November"},
			{"Dec", "December"},
	};

	private String parseString;
	private List<Date> parsedDates;
	private List<DateGroup> parsedDateGroups;
	private DateClass date;
	private TimeClass time;
	
	public String getParseString() {
		return parseString;
	}


	public String getParsedDate() {
		return parsedDates.get(0).toString();
	}

	public DateClass getDate(){
		return date;
	}
	
	public TimeClass getTime(){
		return time;
	}
	
	public List<String> getParsedDateGroup() {
		ArrayList<String> dateGroups = new ArrayList<String>();
		
		for(DateGroup dg : parsedDateGroups){
			dateGroups.add(dg.getText());
		}
		return dateGroups;
	}

	
	public PrettyTimeWrapper(String stringToParse) {
		parseString = stringToParse;
		parse();
	}
	
	
	private void parse(){
		PrettyTimeParser p = new PrettyTimeParser();
		parsedDates = p.parse(parseString);
		parsedDateGroups = p.parseSyntax(parseString);
	
		if(!parsedDates.isEmpty()){
			date = parseDate(parsedDates.get(0).toString());
			time = parseTime(parsedDates.get(0).toString());
		}
			
	}
	
	public TimeClass parseTime(String command){
		String[] words = command.split(" ");
		
		for(String word : words){
			if(word.contains(":")){
				String[] timeDetails = word.split(":");
				return new TimeClass(timeDetails[0], timeDetails[1]);
			}
		}
		
		return null;
	}
	
	public DateClass parseDate(String command){
		command = command.replace("[", "");
		command = command.replace("]", "");
		
		String[] words = command.split(" ");
		
		String day = words[2];
		String month = getMonth(words[1]);
		String year = words[words.length-1];
		
		try {
			return new DateClass(day, month, year);
		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		} catch (ParseException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	private String getMonth(String month){
		for(int i = 0; i < 12; i++){
			if(prettyTimeMonths[i][0].equals(month)){
				return prettyTimeMonths[i][1];
			}
		}
		
		return null;
	}
	
	
}
```
###### Redo.java
``` java
package main;

public class Redo extends Command {

	public Redo(){
		super(CommandType.REDO);
	}
}
```
###### Save.java
``` java
package main;

public class Save extends Command {
	
	private String pathLocation;
	
	public Save(){
		super(CommandType.SAVE);
	}
	
	public Save(String pathLocation){
		super(CommandType.SAVE);
		this.pathLocation = pathLocation;
	}
	
	public String getPathLocation() {
		return pathLocation;
	}

	public void setPathLocation(String pathLocation) {
		this.pathLocation = pathLocation;
	}
	
	
	
}
```
###### Search.java
``` java
package main;

import java.util.ArrayList;

public class Search extends Command {
	
	private String strSearchString;
	private DateClass firstDate, secondDate;
	private boolean before,after,between, on;
	
	public String getStrSearchString() {
		return strSearchString;
	}

	public boolean isBefore() {
		return before;
	}
	
	public boolean isOn() {
		return on;
	}
	
	public boolean isAfter() {
		return after;
	}

	public boolean isBetween() {
		return between;
	}

	public void setBefore(boolean before) {
		this.before = before;
	}

	public void setOn(boolean on) {
		this.on = on;
	}
	
	public void setAfter(boolean after) {
		this.after = after;
	}

	public void setBetween(boolean between) {
		this.between = between;
	}

	public Search(String searchString, DateClass firstDate, DateClass secondDate){
		super(CommandType.SEARCH);
		strSearchString = searchString;
		this.firstDate = firstDate;
		this.secondDate = secondDate;
		 
	}

	public Search(String searchString){
		this(searchString, null, null);	 
	}

	public Search(String searchString, DateClass firstDate){
		this(searchString, firstDate, null);	 
	}
	
	public Search(DateClass firstDate){
		this(null, firstDate, null);	 
	}
	
	public Search(DateClass firstDate, DateClass secondDate){
		this(null, firstDate, secondDate);	 
	}
	
	public String getSearchStrings(){
		return strSearchString;
	}
	
	
	public DateClass getFirstDate(){
		return firstDate;
	}
	
	public DateClass getSecondDate(){
		return secondDate;
	}

}
```
###### Task.java
``` java
package main;

public abstract class Task implements Comparable<Task> {

	private String strDescription;
	private boolean isDone;

	public Task(String description) {
		strDescription = description;
		isDone = false;
	}

	public String getDescription() {
		return strDescription;
	}

	public void setDescription(String strDescription) {
		this.strDescription = strDescription;
	}

```
###### TimeClass.java
``` java
package main;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class TimeClass implements Comparable<TimeClass>{

	private int intHour;
	private int intMin;
	private String strHour;
	private String strMin;

	public TimeClass(String hour, String min){
		this.strHour = hour;
		this.strMin = min;

		this.intHour = Integer.valueOf(hour);
		this.intMin = Integer.valueOf(min);
	}

	public TimeClass(String strhhMM){
		TimeClass time = TimeHandler.parse(strhhMM);
		intHour = time.intHour;
		intMin = time.intMin;

		this.strHour = time.getStringHour();
		this.strMin = time.getStringMin();

	}
	//Added  by [Ravi] to check for overdue task
	public TimeClass(int hourNow, int minuteNow) {
		this.intHour = hourNow;
		this.intMin = minuteNow;

		this.strHour = hourNow + "";
		this.strMin = minuteNow+ "";

	}

	public int getIntHour(){
		return intHour;
	}

	public int getIntMin(){
		return intMin;
	}
	public String getStringHour(){
		return strHour;
	}
	public String getStringMin(){
		return strMin;
	}

	@Override
	public String toString(){
		return strHour + "" + strMin;
	}

	public String to24HourFormat(){
		return toString() + "h";
	}

	public String to12HourFormat(){
		String str24hour = strHour + ":" + strMin;
		DateFormat df = new SimpleDateFormat("HH:mm");
		Date date;
		try {
			date = df.parse(str24hour);
		} catch (ParseException e) {
			return null;
		}

		DateFormat df2 = new SimpleDateFormat("h:mma");
		String asd = df2.format(date);
		return asd;
	}

```
###### TimeHandler.java
``` java
package main;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;


public class TimeHandler {

	public static final String PATTERN_24_HOUR = "([01][0-9]|2[0-3]):?[0-5][0-9][h]?";
	public static final String PATTERN_12_HOUR = "^(0?[1-9]|1[012])(:?[0-5]\\d)?[AaPp][Mm]";
	
	public static int getHourNow(){
		DateFormat dateFormat = new SimpleDateFormat("HH");
		Date date = new Date();
		String strHour = dateFormat.format(date);
		int intHour = Integer.valueOf(strHour);

		return intHour;
	}

	public static int getMinuteNow(){
		DateFormat dateFormat = new SimpleDateFormat("mm");
		Date date = new Date();
		String strMinute = dateFormat.format(date);
		int intMinute = Integer.valueOf(strMinute);

		return intMinute;
	}

	private static int[] parseHourAndMin(String strHHMM){
		String strHour = "" + strHHMM.charAt(0) + strHHMM.charAt(1);
		String strMin = "" + strHHMM.charAt(2) + strHHMM.charAt(3);

		int[] intHourAndMin = new int[2];
		intHourAndMin[0] = Integer.valueOf(strHour);
		intHourAndMin[1] = Integer.valueOf(strMin);

		return intHourAndMin;
	}

	public static TimeClass parse(String strTime){

		String[] strHourAndMin = new String[2];
		
		if(strTime.matches(PATTERN_24_HOUR)){
			strTime = strTime.replace(":", "");
			strTime = strTime.replace("h", "");
			strHourAndMin[0] = "" + strTime.charAt(0) + strTime.charAt(1);
			strHourAndMin[1] = "" + strTime.charAt(2) + strTime.charAt(3);
			

			TimeClass time = new TimeClass(strHourAndMin[0], strHourAndMin[1]);

			return time;

		} 
		else
			return null;

	}

	public static boolean isBeforeNow(TimeClass time){
		TimeClass currentTime = new TimeClass(TimeHandler.getHourNow(), TimeHandler.getMinuteNow());
		
		return time.compareTo(currentTime) < 0 ? true : false;
	}
	
	public static boolean isNow(TimeClass time){
		TimeClass currentTime = new TimeClass(TimeHandler.getHourNow(), TimeHandler.getMinuteNow());
		
		return time.compareTo(currentTime) == 0 ? true : false;
	}
}
```
###### Undo.java
``` java
package main;

public class Undo extends Command{

	public Undo(){
		super(CommandType.UNDO);
	}
}
```
###### Update.java
``` java
package main;

public class Update extends Command {

	private UpdateTask taskToUpdate;
	private UpdateTask updatedTask;
	
	private Task currentTask ;
	private Task updateTask;
	

	/**
	 * @param searchString
	 */
	public Update(UpdateTask taskToUpdate) {
		super(Command.CommandType.UPDATE);

		this.taskToUpdate = taskToUpdate;
	}

	public Update(UpdateTask taskToUpdate, UpdateTask updatedTask) {
		super(Command.CommandType.UPDATE);

		this.taskToUpdate = taskToUpdate;
		this.updatedTask = updatedTask;
	}

	public UpdateTask getTaskToUpdate() {
		return taskToUpdate;
	}

	public void setTaskToUpdate(UpdateTask taskToUpdate){
		this.updatedTask = taskToUpdate;
	}

	public void setUpdatedTask(UpdateTask updatedTask){
		this.updatedTask = updatedTask;
	}
	
	public UpdateTask getUpdatedTask() {
		return updatedTask;
	}
```
###### UpdateTask.java
``` java
package main;

public class UpdateTask extends Task{

	private static final int START_DATE = 0;
	private static final int START_TIME = 0;
	private static final int END_DATE = 1;
	private static final int END_TIME = 1;
	private static final int MAX_DATETIME_COUNT = 2;

	private DateClass[] dates;
	private TimeClass[] time;
	private String strDescription;
	private int taskId;
	
	public UpdateTask(){
		super(null);
		strDescription = null;
		dates = new DateClass[MAX_DATETIME_COUNT];
		time = new TimeClass[MAX_DATETIME_COUNT];
	}

	/**
	 * @return
	 */
	public int getDateCount(){
		int intCount = 0;
		for(int i = 0; i < MAX_DATETIME_COUNT; i++){
			if(dates[i] != null){
				intCount++;
			}
		}

		return intCount;
	}

	/**
	 * @return
	 */
	public int getTimeCount(){
		int intCount = 0;
		for(int i = 0; i < MAX_DATETIME_COUNT; i++){
			if(time[i] != null){
				intCount++;
			}
		}

		return intCount;
	}

	/**
	 * @return
	 */
	public boolean hasDescription(){
		return strDescription != null;
	}

	/**
	 * @return
	 */
	public boolean hasStartDate(){
		return dates[START_DATE] != null;
	}

	/**
	 * @return
	 */
	public boolean hasEndDate(){
		return dates[END_DATE] != null;
	}

	/**
	 * @return
	 */
	public boolean hasStartTime(){
		return time[START_TIME] != null;
	}

	/**
	 * @return
	 */
	public boolean hasEndTime(){
		return time[END_TIME] != null;
	}

	/**
	 * @param startDate
	 */
	public void setStartDate(DateClass startDate) {
		dates[START_DATE] = startDate;

	}

	/**
	 * @param endDate
	 */
	public void setEndDate(DateClass endDate) {
		dates[END_DATE] = endDate;
	}

	/**
	 * @param startTime
	 */
	public void setStartTime(TimeClass startTime) {
		time[START_TIME] = startTime;
	}

	/**
	 * @param endTime
	 */
	public void setEndTime(TimeClass endTime) {
		time[END_TIME] = endTime;
	}

	public void setTaskID(int taskID){
		this.taskId = taskID;
	}

	/**
	 * @param strDescription
	 */
	public void setDescription(String strDescription) {
		this.strDescription = strDescription;
	}

	/**
	 * @return
	 */
	public DateClass getStartDate() {
		return dates[START_DATE];
	}

	/**
	 * @return
	 */
	public DateClass getEndDate() {
		return dates[END_DATE];
	}

	/**
	 * @return
	 */
	public TimeClass getStartTime() {
		return time[START_TIME];
	}

	/**
	 * @return
	 */
	public TimeClass getEndTime() {
		return time[END_TIME];
	}

	public int getTaskID(){
		return taskId;
	}
	
	public String getDescription() {
		return strDescription;
	}

	@Override
	public int compareTo(Task o) {
		// TODO Auto-generated method stub
		return 0;
	}

	
}
```
